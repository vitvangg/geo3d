using System;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
using System.Diagnostics;
using Debug = UnityEngine.Debug;
#endif

namespace GD3D.Level
{
    /// <summary>
    /// A class which contains data all about the Objects in Levels. It also handles the loading of Objects but NOT the spawning of them. See <see cref="LevelObjectSpawner"/> for spawning Objects.
    /// </summary>
    public class LevelObjectManager
    {
        #region File Navigation Strings
#if UNITY_EDITOR
        /// <summary>
        /// The folder for where the the Object Paths file is located. <para/>
        /// Please note that this is only available in the Unity Editor. So don't use this in a build.
        /// </summary>
        public static readonly string Folder = Path.Combine(Application.dataPath, "Resources", OBJ_FOLDER);
        /// <summary>
        /// The file path to the Object Data file. <para/>
        /// Please note that this is only available in the Unity Editor. So don't use this in a build. <para/>
        /// Instead you should use "<see cref="DataTextAsset"/>" in builds.
        /// </summary>
        public static readonly string DataFilePath = Path.Combine(Folder, DATA_FILE_NAME + ".txt");
        /// <summary>
        /// The file path to the Object Fields Data file. <para/>
        /// Please note that this is only available in the Unity Editor. So don't use this in a build. <para/>
        /// Instead you should use "<see cref="FieldTextAsset"/>" in builds.
        /// </summary>
        public static readonly string FieldFilePath = Path.Combine(Folder, FIELD_FILE_NAME + ".txt");

        public const string PREFAB_EXTENSION = ".prefab";
#endif

        public const string OBJ_FOLDER = "Objects";

        public const string DATA_FILE_NAME = "Object Data";
        public const string FIELD_FILE_NAME = "Object Fields Data";
        #endregion

        #region Text Assets
        private static TextAsset _cachedDataTextAsset;

        /// <summary>
        /// The data text asset which contains data about the objects ID, the objects name and where the objects prefab is stored.
        /// </summary>
        public static TextAsset DataTextAsset
        {
            get
            {
                if (_cachedDataTextAsset == null)
                {
                    try
                    {
                        _cachedDataTextAsset = Resources.Load<TextAsset>(Path.Combine(OBJ_FOLDER, DATA_FILE_NAME));
                    }
                    catch (Exception)
                    {
                        // Fail :(
                        return null;
                    }
                }

                return _cachedDataTextAsset;
            }
        }

        private static TextAsset _cachedFieldsTextAsset;

        /// <summary>
        /// The data text asset which contains data about the objects savable fields and what ID those fields have.
        /// </summary>
        public static TextAsset FieldTextAsset
        {
            get
            {
                if (_cachedFieldsTextAsset == null)
                {
                    try
                    {
                        _cachedFieldsTextAsset = Resources.Load<TextAsset>(Path.Combine(OBJ_FOLDER, FIELD_FILE_NAME));
                    }
                    catch (Exception)
                    {
                        // Fail :(
                        return null;
                    }
                }

                return _cachedFieldsTextAsset;
            }
        }
        #endregion

        public const char LINE_CHAR = '\n';
        public const char SEPERATOR_CHAR = '|';
        public const char FIELD_SEPERATOR_CHAR = ',';
        public const string NO_COMPONENT_STRING = "\"none\"";

        private static readonly BindingFlags _fieldBindingFlags = BindingFlags.Instance;

        #region Top Text
        public const string DATA_TOP_TEXT =
@"// This file is used to get data of what ID an object it has, where the Prefab is stored, and what components it has.
// DO NOT edit this manually and DON'T delete this file as it is automatically generated by the ""LevelObjects"" script.
// NOTE: Any prefabs placed in a folder named ""Exclude"" (Caps don't matter) will be ignored completely.

";

        public const string FIELD_TOP_TEXT =
@"// This file is used to get data of which Class Type has fields marked with the ""LevelSave"" attribute.
// This file also shows the ID of every single field which is used to distinquish the fields between eachother.
// DO NOT edit this manually and DON'T delete this file as it is automatically generated by the ""LevelObjects"" script.

";
        #endregion

        //-- Object Data Collections (this is proof that I love dictionaries)
        public static Dictionary<string, ulong> ObjectIDs = new Dictionary<string, ulong>();
        public static Dictionary<ulong, string> ObjectNames = new Dictionary<ulong, string>();
        public static Dictionary<ulong, GameObject> Objects = new Dictionary<ulong, GameObject>();
        public static Dictionary<ulong, Dictionary<ulong, Type>> ObjectComponents = new Dictionary<ulong, Dictionary<ulong, Type>>();

        private static HashSet<ulong> _takenObjectIDs = new HashSet<ulong>();

        //-- Object Field Collections (these might be a bit confusing)
        public static Dictionary<ulong, Type> SavableTypes = new Dictionary<ulong, Type>();
        public static Dictionary<Type, ulong> SavableTypeIDs = new Dictionary<Type, ulong>();
        public static Dictionary<Type, Dictionary<string, ulong>> ObjectFieldIDs = new Dictionary<Type, Dictionary<string, ulong>>();
        public static Dictionary<Type, Dictionary<ulong, string>> ObjectFieldNames = new Dictionary<Type, Dictionary<ulong, string>>();
        public static Dictionary<Type, Dictionary<ulong, FieldInfo>> ObjectFields = new Dictionary<Type, Dictionary<ulong, FieldInfo>>();

        private static Dictionary<Type, HashSet<ulong>> _takenFieldIDs = new Dictionary<Type, HashSet<ulong>>();
        private static Dictionary<Type, HashSet<string>> _existingFields = new Dictionary<Type, HashSet<string>>();
#if UNITY_EDITOR
        // Just a list of object types that have been written in the Object Field Data file
        private static HashSet<Type> _writtenTypes = new HashSet<Type>();
#endif

        [RuntimeInitializeOnLoadMethod]
        public static void InitializeOnLoad()
        {
            LoadObjectFields();
            LoadObjects();
        }

        public static void LoadObjects()
        {
            // Clear all of our collections
            Objects.Clear();
            ObjectIDs.Clear();
            ObjectNames.Clear();
            ObjectComponents.Clear();
            _takenObjectIDs.Clear();

            // Do nothing if the text asset is non-existent.
            if (DataTextAsset == null)
            {
                return;
            }

            ReadTextAsset(DataTextAsset, (split) =>
            {
                // Ignore the split if it doesn't have exactly 3 strings in the array (failsafe)
                if (split.Length != 4)
                {
                    return;
                }

                // Try to get the ID and return if it fails
                if (!ulong.TryParse(split[0], out ulong id))
                {
                    return;
                }

                // Add the ID to our dictionaries
                ObjectIDs.Add(split[1], id);
                ObjectNames.Add(id, split[1]);

                // Load the GameObject using our special method
                GameObject obj = LoadObject(split[2]);

                if (obj == null)
                {
                    return;
                }

                // Add the id and loaded GameObject to the Objects dictionary
                Objects.Add(id, obj);

                // Also add that it's taken
                _takenObjectIDs.Add(id);

                // Split the split to get the component split (yknow?)
                string[] componentTypes = split[3].Split(FIELD_SEPERATOR_CHAR, StringSplitOptions.RemoveEmptyEntries);

                // Ignore this objects components if it begins with "none"
                if (componentTypes[0] == NO_COMPONENT_STRING)
                {
                    return;
                }

                // Loop through all component types
                foreach (string typeName in componentTypes)
                {
                    Type componentType = Type.GetType(typeName);

                    // Go to the next if the component type is null
                    if (componentType == null)
                    {
                        continue;
                    }

                    // Try to get the component from the object
                    if (!obj.TryGetComponent(componentType, out _))
                    {
                        // If that fails, the we go to the next component
                        continue;
                    }

                    if (!SavableTypeIDs.ContainsKey(componentType))
                    {
                        continue;
                    }

                    // Above tests didn't fail

                    // Add dictionaries if the key is missing
                    if (!ObjectComponents.ContainsKey(id))
                    {
                        ObjectComponents.Add(id, new Dictionary<ulong, Type>());
                    }

                    // Add both component and component type to the dictionaries
                    ObjectComponents[id].Add(SavableTypeIDs[componentType], componentType);
                }
            });
        }

        private static GameObject LoadObject(string name)
        {
            return Resources.Load<GameObject>(Path.Combine(OBJ_FOLDER, name));
        }

        public static void LoadObjectFields()
        {
            // Clear all of our collections
            SavableTypes.Clear();
            ObjectFieldIDs.Clear();
            ObjectFieldNames.Clear();
            ObjectFields.Clear();
            _takenFieldIDs.Clear();
            _existingFields.Clear();

            // Do nothing if the text asset is non-existent.
            if (FieldTextAsset == null)
            {
                return;
            }

            ReadTextAsset(FieldTextAsset, (split) =>
            {
                if (split.Length < 3)
                {
                    return;
                }

                // Try to get the ID of the type
                if (!ulong.TryParse(split[0], out ulong id))
                {
                    return;
                }

                if (string.IsNullOrEmpty(split[1]))
                {
                    return;
                }

                // Get the class type
                Type type = Type.GetType(split[1]);

                if (type == null)
                {
                    return;
                }

                // Add the class type to the dictionaries using this method
                AddFieldClassType(id, type);

                // Loop through the remaining splits as they are all savable fields
                int length = split.Length;

                for (int i = 2; i < length; i++)
                {
                    // Split the split to get the field split (yknow?)
                    string[] fieldSplit = split[i].Split(FIELD_SEPERATOR_CHAR, StringSplitOptions.RemoveEmptyEntries);

                    if (fieldSplit.Length != 2)
                    {
                        return;
                    }

                    // Get the id of the field
                    if (!ulong.TryParse(fieldSplit[1], out ulong fieldID))
                    {
                        continue;
                    }

                    // Try to get the field from the type
                    FieldInfo field = type.GetField(fieldSplit[0]);

                    if (field == null)
                    {
                        field = type.GetRuntimeField(fieldSplit[0]);
                    }

                    if (field == null)
                    {
                        continue;
                    }

                    // Add the field to all of the collections
                    ObjectFieldIDs[type].Add(fieldSplit[0], fieldID);
                    ObjectFieldNames[type].Add(fieldID, fieldSplit[0]);
                    ObjectFields[type].Add(fieldID, field);
                    _takenFieldIDs[type].Add(fieldID);
                    _existingFields[type].Add(fieldSplit[0]);
                }
            });
        }

        private static void AddFieldClassType(ulong id, Type type)
        {
            if (!SavableTypes.ContainsKey(id)) SavableTypes.Add(id, type);
            if (!SavableTypeIDs.ContainsKey(type)) SavableTypeIDs.Add(type, id);
            if (!ObjectFieldIDs.ContainsKey(type)) ObjectFieldIDs.Add(type, new Dictionary<string, ulong>());
            if (!ObjectFieldNames.ContainsKey(type)) ObjectFieldNames.Add(type, new Dictionary<ulong, string>());
            if (!_existingFields.ContainsKey(type)) _existingFields.Add(type, new HashSet<string>());
            if (!_takenFieldIDs.ContainsKey(type)) _takenFieldIDs.Add(type, new HashSet<ulong>());
        }

        /// <summary>
        /// This is here for cleaner code mostly.
        /// </summary>
        private static void ReadTextAsset(TextAsset asset, Action<string[]> action)
        {
            // Get the raw text from the text asset
            string rawText = asset.text;

            // Split the raw text at every new line
            string[] lines = rawText.Split(LINE_CHAR, StringSplitOptions.RemoveEmptyEntries);

            foreach (string line in lines)
            {
                // Ignore lines which are empty or start with "//" (meaning that line is a comment)
                if (string.IsNullOrWhiteSpace(line) || line.StartsWith("//"))
                {
                    continue;
                }

                // Split the line between every Seperator Char (which is a line character | )
                string[] split = line.Split(SEPERATOR_CHAR);

                action?.Invoke(split);
            }
        }

#if UNITY_EDITOR
        [MenuItem("Developer/Generate Level Object Files")]
        private static void Generate()
        {
            Stopwatch watch = new Stopwatch();

            watch.Start();

            // Generate file for object fields first
            LoadObjectFields();

            // Create a new string builder which we will use instead of creating a regular string
            // This is obviously because string builder is way cooler (and also more optimized I think)
            StringBuilder builder = new StringBuilder(FIELD_TOP_TEXT);

            GenerateFieldFile(ref builder);

            // Sort all the lines in the builder by their ID at the start of the line
            // EXAMPLE:
            //--
            // Before:
            // 2|THIS IS A LINE
            // 5|THIS TOO IS A LINE
            // 4|FOURTH LINE!!!
            // 1|LAST LINE IS SUPPOSED TO BE FIRST
            //--
            // After:
            // 1|LAST LINE IS SUPPOSED TO BE FIRST
            // 2|THIS IS A LINE
            // 4|FOURTH LINE!!!
            // 5|THIS TOO IS A LINE

            SortStringBuilder(ref builder);

            // Write all of our data from our builder into the file
            File.WriteAllText(FieldFilePath, builder.ToString().TrimEnd());

            //UpdateParentTypes();

            // Generate file for object data
            LoadObjects();

            // Clear string builder (pretty much the same as creating a new one but this allocates less memory!)
            builder.Clear();
            builder.Append(DATA_TOP_TEXT);

            // Search through all directories in the folder
            SearchDirectory(Folder, ref builder);

            // Sort all the lines in the builder by their ID at the start of the line
            SortStringBuilder(ref builder);

            // Write all of our data from our builder into the file
            File.WriteAllText(DataFilePath, builder.ToString().TrimEnd());
            
            watch.Stop();

            Debug.Log("TIME: " + ((decimal)watch.ElapsedMilliseconds / 1000M));
            // This system makes it take around 1 second extra to compile code in Unity
        }

        /// <summary>
        /// Will sort every single line in a string builder by which ID is biggest
        /// </summary>
        private static void SortStringBuilder(ref StringBuilder builder)
        {
            string[] split = builder.ToString().Split(LINE_CHAR);

            HashSet<int> sortedIndexes = new HashSet<int>();
            Dictionary<ulong, string> lines = new Dictionary<ulong, string>();

            int index = -1;

            foreach (string line in split)
            {
                index++;

                if (string.IsNullOrEmpty(line) || line.StartsWith("//"))
                {
                    continue;
                }

                string[] lineSplit = line.Split(SEPERATOR_CHAR);

                if (lineSplit.Length < 1)
                {
                    continue;
                }

                if (!ulong.TryParse(lineSplit[0], out ulong lineOrder))
                {
                    continue;
                }

                sortedIndexes.Add(index);

                lines.Add(lineOrder, line);
            }

            builder.Clear();

            index = -1;
            ulong order = 0;
            int amountSorted = 0;
            int totalLines = lines.Count;

            foreach (string line in split)
            {
                index++;

                // If the amount we have sorted is greater or equal to the length of total lines, then we are done sorting our lines!
                // Also check if this index is NOT supposed to be sorted
                if (amountSorted >= totalLines || !sortedIndexes.Contains(index))
                {
                    // If so, then we just append the regular line without any fancy ordering
                    builder.Append(line);

                    continue;
                }

                // This line is supposed to be sorted!
                // So we start by looping until the we find a line that exists
                while (!lines.ContainsKey(order))
                {
                    order++;
                }

                // Append the line with the proper order
                builder.Append(lines[order]);
                builder.Append(LINE_CHAR);
                amountSorted++;
                
                // Add to order so that our next line is different
                order++;
            }
        }

        private static void SearchDirectory(string directory, ref StringBuilder builder)
        {
            // Get all files
            string[] files = Directory.GetFiles(directory);

            // Loop through all the files
            foreach (string path in files)
            {
                // Ignore all files that are not prefabs
                if (Path.GetExtension(path).ToLower() != PREFAB_EXTENSION)
                {
                    continue;
                }

                SetObjectData(path, ref builder);
            }

            // Search all other directories in this directory
            string[] directories = Directory.GetDirectories(directory);

            foreach (string path in directories)
            {
                // Ignore folder paths that end with "exclude"
                if (path.ToLower().EndsWith("exclude"))
                {
                    continue;
                }

                // Harness the power of ocasional (not infinite) recursion
                SearchDirectory(path, ref builder);
            }
        }

        private static void SetObjectData(string path, ref StringBuilder builder)
        {
            string objName = Path.GetFileNameWithoutExtension(path);

            // The asset path is the path without all the other folders before it
            // Before: C:\My Computer\My Game\Assets\Resources\Objects\Folder\My Object.prefab
            // After: Folder\My Object.prefab
            string assetPath = path.Substring(Folder.Length + 1);

            // Now we remove the extension part of the name
            // Before: Folder\My Object.prefab
            // After: Folder\My Object
            assetPath = assetPath.Substring(0, assetPath.Length - PREFAB_EXTENSION.Length);

            // This is how we convert our previous full path into an Asset Path

            // Get the ID of this object if it has an ID, otherwise the ID will be 0
            bool hasId = ObjectIDs.ContainsKey(objName);
            ulong id = hasId ? ObjectIDs[objName] : 0;

            // Loop until we find a unique ID (if we don't have an ID yet)
            if (!hasId)
            {
                while (_takenObjectIDs.Contains(id))
                {
                    id++;
                }

                _takenObjectIDs.Add(id);
            }

            // Add all of our current data to the string builder
            builder.Append(id);
            builder.Append(SEPERATOR_CHAR);
            builder.Append(objName);
            builder.Append(SEPERATOR_CHAR);
            builder.Append(assetPath);
            builder.Append(SEPERATOR_CHAR);

            //-- Now check for savable components attached to the game object

            // Get the object our ID is reffering to (or just directely load it if we just generated a new ID)
            GameObject obj = hasId ? Objects[id] : LoadObject(assetPath);

            // Create a bool which will check wether or not this object has any savable components attached
            bool hasComponents = false;

            // Loop through all savable types to check if our object has one attached to it
            foreach (var pair in SavableTypes)
            {
                // Go to the next type if this component type is not attached this game object
                if (!obj.TryGetComponent(pair.Value, out _))
                {
                    continue;
                }

                // Set the hasComponents variable to true if it's false
                if (!hasComponents)
                {
                    hasComponents = true;
                }
                // However if hasComponents is already true, then we append another field seperator char to the string builder
                // This is added so we can use String.Split to split the string at every field seperator char when we need to read the text file
                else
                {
                    builder.Append(FIELD_SEPERATOR_CHAR);
                }

                // Add the name of the component type to the string builder
                // This must be the full name as thus we are able to differenciate between every single type in the game
                builder.Append(pair.Value.FullName);
            }

            // Check if hasComponents is false
            if (!hasComponents)
            {
                // And if so, then we simply add the no component string to the builder as this object has no savable components
                builder.Append(NO_COMPONENT_STRING);
            }

            // Add the line char to the end of the string builder to signify a new line
            builder.Append(LINE_CHAR);
        }

        private static void GenerateFieldFile(ref StringBuilder builder)
        {
            //-- Major loopage incoming (AKA. Very nested code)

            // Loop through all assemblies in the whole app
            foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
            {
                // Loop through all Class Types in the assembly
                foreach (Type type in assembly.GetTypes())
                {
                    bool changedBuilder = false;

                    // Loop through all of the regular fields in the Type
                    foreach (FieldInfo field in type.GetFields(_fieldBindingFlags))
                    {
                        SearchClassField(type, field, ref builder, ref changedBuilder);
                    }

                    // Also loop through all of the runtime fields in the Type
                    foreach (FieldInfo field in type.GetRuntimeFields())
                    {
                        SearchClassField(type, field, ref builder, ref changedBuilder);
                    }

                    // Add a new line if the builder was changed
                    if (changedBuilder)
                    {
                        builder.Append(LINE_CHAR);
                    }
                }
            }
        }

        private static void SearchClassField(Type type, FieldInfo field, ref StringBuilder builder, ref bool changedBuilder)
        {
            // Ignore fields that are not serializable (meaning they can't be converted to json)
            if (!field.FieldType.IsSerializable || field.IsNotSerialized)
            {
                return;
            }
            
            // Check if the field has a "LevelSave" attribute attached to it
            LevelSaveAttribute attribute = field.GetCustomAttribute<LevelSaveAttribute>(true);

            // Return if the field didn't have a "LevelSave" attribute attached
            if (attribute == null)
            {
                return;
            }

            // Get the ID of this savable type if it has an ID, otherwise the ID will be 0
            bool hasId = SavableTypeIDs.ContainsKey(type);
            ulong id = hasId ? SavableTypeIDs[type] : 0;

            // Loop until we find a unique ID (if we don't have an ID yet)
            if (!hasId)
            {
                while (SavableTypes.ContainsKey(id))
                {
                    id++;
                }
                
                SavableTypes.Add(id, type);
                SavableTypeIDs.Add(type, id);
            }

            // Add the field class type
            AddFieldClassType(id, type);

            if (!_writtenTypes.Contains(type))
            {
                builder.Append($"{id}{SEPERATOR_CHAR}{type.FullName}");

                _writtenTypes.Add(type);
            }

            _existingFields[type].Add(field.Name);

            // Get collections for this Type
            Dictionary<string, ulong> dictionary = ObjectFieldIDs[type];
            HashSet<ulong> takenIDs = _takenFieldIDs[type];

            // Get the ID of this object if it has an ID, otherwise the ID will be 0
            hasId = dictionary.ContainsKey(field.Name);
            id = hasId ? dictionary[field.Name] : 0;

            // Loop until we find a unique ID (if we don't have an ID yet)
            if (!hasId)
            {
                while (takenIDs.Contains(id))
                {
                    id++;
                }

                takenIDs.Add(id);

                dictionary.Add(field.Name, id);
                ObjectFieldNames[type].Add(id, field.Name);
            }

            // Add all of the data to the string builder
            builder.Append($"{SEPERATOR_CHAR}{field.Name}{FIELD_SEPERATOR_CHAR}{id}");

            // Set changed builder to true as we changed the builder
            changedBuilder = true;
        }
#endif
    }
}
